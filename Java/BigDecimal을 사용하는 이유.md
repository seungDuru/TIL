자바 백엔드 시스템에서 **금액이나 금전적 계산**을 다룰 때 `BigDecimal`을 사용하는 주된 이유는 **정확한 계산**이 필요하기 때문입니다.

`double`이나 `float` 같은 **부동소수점 타입**은 근사값을 표현하므로 정확하지 않은 결과가 나올 수 있습니다. 반면 `BigDecimal`은 임의 정밀도 소수를 다루도록 설계되어 금액처럼 정밀도가 중요한 값을 처리할 때 유리합니다.

---

### 부동소수점 타입(double, float)의 문제점

`double`과 `float`는 **IEEE 754** 표준을 따르는 **부동소수점 방식**으로 값을 저장합니다. 이 방식은 **이진법** 기반의 실수를 표현하기 때문에 일부 **소수점 숫자를 정확하게 표현하지 못합니다.**

예를 들어,

```java
System.out.println(0.1 + 0.2); // 결과: 0.30000000000000004
```
`

이처럼 0.1과 0.2를 더해도 **0.3**이 아닌 **근사값**이 나옵니다. 이는 부동소수점 숫자가 이진법으로 변환될 때 정확하게 표현되지 않기 때문입니다.

### BigDecimal의 장점

1. **정확한 계산**: `BigDecimal`은 **정확한 숫자 표현**과 **정밀도 제어**가 가능합니다.
2. **금전 계산에 최적**: 소수점 자리수가 중요한 **금전 계산**에 정확성을 보장합니다.
3. **부동소수점의 오차 방지**: IEEE 754 방식에서 발생하는 **오차 문제**를 피할 수 있습니다.
4. **임의 정밀도**: 필요한 만큼 소수점 이하 자리를 제어할 수 있습니다.

### BigDecimal의 단점 및 유의점

1. **성능 저하**: `BigDecimal`은 `double`이나 `float`보다 속도가 느립니다. 이유는 내부적으로 문자열처럼 숫자를 다루기 때문입니다.
2. **복잡한 문법**:
    - `BigDecimal` 간의 사칙연산이 연산자(`+`, `-`, `*`, `/`)를 지원하지 않고 메서드를 사용해야 합니다.
        
        java
        
        코드 복사
        
        `BigDecimal a = new BigDecimal("0.1"); BigDecimal b = new BigDecimal("0.2"); BigDecimal result = a.add(b); // 더하기 System.out.println(result); // 결과: 0.3`
        
    - 값 비교 시 `compareTo()`를 사용해야 합니다.
        
        java
        
        코드 복사
        
        `a.compareTo(b); // a < b 이면 -1, 같으면 0, a > b 이면 1`
        
3. **메모리 사용량**: `BigDecimal` 객체는 **메모리를 많이 사용**합니다.

---

## 부동소수점 (Floating-Point)

**부동소수점**이란 숫자를 표현하는 방식 중 하나로, **정수와 소수점이 있는 실수**를 근사적으로 나타내는 방식입니다.

### 부동소수점의 구조

부동소수점 숫자는 **IEEE 754 표준**에 따라 다음과 같은 구조로 구성됩니다.

```scss
부호 비트 (Sign) | 지수 (Exponent) | 가수 (Mantissa)
```

- **부호 비트**: 숫자의 양수/음수를 결정 (0: 양수, 1: 음수)
- **지수 (Exponent)**: 소수점 위치를 조정하는 역할 (2의 지수로 표현)
- **가수 (Mantissa)**: 실수의 유효 숫자 부분

### 부동소수점의 특징

1. **근사값 표현**: 모든 소수를 정확하게 표현하지 못하고 근사값을 저장합니다.
    - 예: 0.1, 0.2 같은 값은 이진수로 정확하게 표현할 수 없습니다.
2. **범위는 넓지만 정밀도 한계**: 넓은 범위의 값을 표현할 수 있지만 소수점 이하의 정밀도는 제한됩니다.
3. **연산 오차 발생**: 덧셈, 뺄셈, 곱셈, 나눗셈 등 연산을 수행하면 **오차가 누적**될 수 있습니다.

### 부동소수점 예시

0.1을 이진수로 변환하면 무한소수입니다.

```scss
0.1 (10진수) → 0.00011001100110011...(2진수)
```

이 값은 **유한한 메모리**에 저장할 수 없으므로 일부를 잘라서 근사값으로 저장하게 됩니다. 따라서 연산 과정에서 오차가 발생하게 됩니다.

### **유의사항**

- `BigDecimal`은 문자열로 값을 생성해야 부동소수점 오차를 방지할 수 있습니다.
```java
BigDecimal a = new BigDecimal("0.1"); // 올바름 BigDecimal b = new BigDecimal(0.1);   // 부동소수점 오차 발생
```

---
## **결론**
- **금전 계산**과 같이 정밀도가 중요한 경우 `BigDecimal`을 사용해야 합니다.
- `double`이나 `float`는 부동소수점 표현으로 인해 정확한 계산이 어려워 **오차**가 발생할 수 있습니다.
- `BigDecimal`은 성능이 다소 느리지만, 정확한 값을 보장한다는 점에서 금융, 회계 시스템 개발에 필수적입니다.