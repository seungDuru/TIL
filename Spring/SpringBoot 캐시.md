# 스프링부트 캐시에 대해 알아보기

스프링부트에서 애플리케이션 성능을 최적화하기 위해 가장 많이 사용되는 기능 중 하나는 캐시이다. 캐시는 동일한 데이터를 반복적으로 요청할 때, 데이터베이스나 외부 서비스 호출 없이 빠르게 응답할 수 있도록 메모리에 데이터를 저장하는 기법이다. 이 글에서는 스프링부트에서 캐시를 사용하여 애플리케이션 성능을 개선하는 방법에 대해 알아본다.

## 1. 캐시의 필요성
캐시는 서버의 부하를 줄이고, 데이터베이스 요청 시간을 줄임으로써 애플리케이션의 응답 시간을 획기적으로 줄여준다. 특히, 데이터베이스 요청이 많은 경우나 외부 API 호출이 빈번한 경우, 캐시를 활용하여 시스템의 전반적인 성능을 개선할 수 있다. 스프링부트는 기본적으로 캐시를 쉽게 설정하고 사용할 수 있도록 다양한 기능을 제공한다.

## 2. 스프링부트에서의 캐시 설정
스프링부트에서 캐시를 사용하려면 `@EnableCaching` 애너테이션을 추가하여 애플리케이션에서 캐싱을 활성화해야 한다. 다음은 기본적인 설정 방법이다.

```java
@SpringBootApplication
@EnableCaching
public class CacheApplication {
    public static void main(String[] args) {
        SpringApplication.run(CacheApplication.class, args);
    }
}
```

`@EnableCaching` 애너테이션을 추가하면 스프링부트가 캐시 관련 빈을 자동으로 생성하고, 캐시 기능을 사용할 준비가 된다.

## 3. 캐시 사용하기
스프링부트에서 메소드의 결과를 캐싱하려면 `@Cacheable` 애너테이션을 사용할 수 있다. 예를 들어, 다음과 같이 메소드에 `@Cacheable`을 적용하여 캐시를 사용할 수 있다.

```java
@Service
public class UserService {
    @Cacheable("users")
    public User getUserById(Long userId) {
        // 데이터베이스에서 사용자 정보를 가져오는 로직
        return userRepository.findById(userId).orElse(null);
    }
}
```

위 코드에서 `getUserById` 메소드는 `users`라는 이름의 캐시를 사용하여 사용자 정보를 캐싱한다. 첫 호출 시에는 데이터베이스에서 정보를 가져오지만, 이후 동일한 사용자 ID로 호출될 경우 캐시된 데이터를 반환하여 성능을 개선한다.

## 4. 캐시 갱신 및 삭제
캐시된 데이터를 갱신하거나 삭제해야 할 경우 `@CachePut`과 `@CacheEvict` 애너테이션을 사용할 수 있다.

- `@CachePut`은 캐시된 데이터를 갱신할 때 사용된다. 데이터 수정 시, 수정된 내용을 캐시에 반영할 수 있다.
- `@CacheEvict`은 캐시된 데이터를 삭제할 때 사용된다. 예를 들어, 사용자가 삭제되거나 업데이트되었을 때 캐시에서 해당 사용자 정보를 제거한다.

```java
@CacheEvict(value = "users", key = "#userId")
public void deleteUser(Long userId) {
    userRepository.deleteById(userId);
}
```

## 5. 캐시 프로바이더
스프링부트는 다양한 캐시 프로바이더를 지원한다. 대표적으로는 다음과 같은 캐시 프로바이더가 있다.

- **ConcurrentMapCache**: 기본적으로 스프링은 간단한 테스트나 개발을 위해 ConcurrentMapCache를 사용한다. 이는 로컬 메모리에 캐시를 저장한다.
- **Ehcache**: 분산 캐시 시스템을 지원하며, 대규모 애플리케이션에서 주로 사용된다.
- **Caffeine**: 고성능 캐시 라이브러리로, 빠른 접근 성능을 제공한다. 특히 로컬 캐시로 적합하다.
- **Redis**: 분산 환경에서 사용하기 좋은 인메모리 데이터 스토어로, 네트워크를 통해 캐시를 저장할 수 있다.

## 6. 로컬 캐시 사용 시 주의점
로컬 캐시는 성능을 향상시키는 데 효과적이지만, 분산 시스템에서는 여러 노드 간의 캐시 동기화 문제가 발생할 수 있다. 따라서 다수의 인스턴스를 사용하는 환경에서는 Redis와 같은 분산 캐시를 사용하는 것이 좋다. 로컬 캐시는 단일 인스턴스 환경이나 데이터 일관성이 크게 중요하지 않은 경우에 적합하다.

## 7. 실전 예제: 국가 정보 캐시하기
사용자의 언어 설정에 따라 국가 정보를 제공해야 한다고 가정해 보자. `getCountries` 메소드를 통해 국가 정보 목록을 가져오는데, 이 데이터를 캐시에 저장하면 각 요청마다 반복적인 데이터베이스 호출을 줄일 수 있다.

```java
@Cacheable(value = "countries", key = "#locale")
public List<Country> getCountries(Locale locale) {
    // 국가 정보 목록을 데이터베이스에서 가져오는 로직
    return countryRepository.findAllByLocale(locale);
}
```
위 예제에서는 언어 설정(`locale`)에 따라 국가 목록을 캐시하여, 사용자 요청 시 빠르게 응답할 수 있도록 한다.

## 8. 마무리
스프링부트에서 캐시를 사용하는 것은 애플리케이션의 성능을 최적화하는 중요한 방법 중 하나이다. 간단한 설정으로 캐시를 활성화하고, 적절한 애너테이션을 사용하여 캐시를 효과적으로 관리할 수 있다. 실제 개발 환경에서 캐시를 올바르게 활용하면 서버 부하를 줄이고, 사용자에게 빠른 응답을 제공하는 데 큰 도움이 될 것이다.

#spring 